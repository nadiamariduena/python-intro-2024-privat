## üü® [Loops](https://youtu.be/23vCap6iYSs?feature=shared&t=36)

- while loops

- for loops

<br>
<br>

---

 <br>

### You will see this more at the bottom

https://www.stechies.com/string-formatting-f-stringin-python/

```python
  # üëæ The f before a string literal in Python denotes an f-string, which is similar to template literals in JavaScript.
      print(f"{i+1}. {playlist[i]}")
#
#
# another example
name = "Alice"
age = 30
print(f"My name is {name} and I am {age} years old.")

```

<br>
<br>

### WHILE loop

- Just like in javascript

- careful with the never ending loop that will crash your browser, so dont **print** the below

```python
value = 1
while value < 10:
    print(value) # :stop_sign: DONT!!!

    #result
    # infinite loop
```

<br>
<br>

### Do this:

- add the `+= 1` its going to increment everytime it goes through the LOOP, until it reaches the 9 (as we are incrementing 1), which is the end point `< 10`

```python
value = 1
while value < 10:
    print(value)
    value += 1
#result
1
2
3
4
5
6
7
8
9
#It doesnt reach the 10, because the condition tells that "WHILE" its less than 10. if you want to show the 10, you can change the condition from < 10 to <= 10 (less or equal to 10)
value = 1
while value <= 10:
    print(value)
    value += 1
#result
1
2
3
4
5
6
7
8
9
10
```

### Another WAY to break the LOOP

```python
value = 1
while value <= 10:
    print(value)
    if value == 5:
        break #if the condition is met, it will stop the loop at 5
    value += 1
```

<br>
<br>

# ELSE

### üñêÔ∏è USING the else

- You can use it once the loop is completed and the condition is no longer TRUE

```python
while value <= 10:
  value += 1
  if value == 5:
     continue  # If value is 5, the loop skips the remaining code in this iteration and continues to the next iteration
  print(value)
  #
  # ELSE: You can use it once the loop is completed and the condition is no longer TRUE
  #
else:
    print("Value is now equal to " + value) #üßß You will get an error if you try to print this, so convert the TYPE

```

## üî¥ the error

```python
    print("Value is now equal to " +  value)
          ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~
TypeError: can only concatenate str (not "int") to str
```

<br>

### üåà convert the TYPE to str (string)

```python
else:
    print("Value is now equal to " + str(value))
```

<br>
<br>

---

<br>
<br>

## üü° FOR loop (sequence)

<br>

#### chatgpt basict doc about the topic:

<br>

- In Python, a for **loop is used to iterate over a sequence (such as a list, tuple, string, or range) or any other iterable object.**

> The basic syntax of a for loop in Python is:

```python

for item in sequence:
    # do something with item

```

#### The `for` keyword indicates the start of the loop.

- **item** is a variable that will take on the value of each element in the sequence during each iteration of the loop.

**sequence** is the collection of items over which the loop will iterate.

```python

fruits = ["apple", "banana", "cherry"]
#
# fruit will represent the content within the fruits list/ array(js)
for fruit in fruits:
    print(fruit)

```

<br>

### In this example, the for loop iterates over the fruits list.

‚úã **During each iteration**, the variable fruit takes on the value of each element in the list ("apple", "banana", and "cherry" in sequence), and it prints each fruit.

You can also use the `range()` function to generate a sequence of numbers:

<br>

```python
for i in range(5):
    print(i)

    # The for loop continues iterating until it has gone through all the elements in the sequence or until a break statement is encountered, which exits the loop prematurely.

# result
# 0
# 1
# 2
# 3
# 4
```

#### The for loop continues iterating until it has gone through all the elements in the sequence or until a break statement is encountered, which exits the loop prematurely.

<br>
<br>

### How can I use the `range()` for a real scenario?

<br>

- Let's imagine you're building a program that simulates a **Spotify** playlist, and you want to display the track numbers along with their titles.

- You can use the `range()` function to generate track numbers dynamically, especially if your playlist can have a variable number of tracks.

<br>

```python
playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
for i in range(len(playlist)):
    print(f"{i+1}. {playlist[i]}")

```

<br>
<br>

```python
#
#

playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
##
# len(playlist) returns the length of the playlist, which is the number of tracks.
#
# i iterates over each number generated by range(), representing the track number.

#
for i in range(len(playlist)):
    #
    #range(len(playlist)) generates a sequence of numbers from 0 to len(playlist) - 1. This sequence corresponds to the indices of the tracks in the playlist.
    #
    print(f"{i+1}. {playlist[i]}")
    #  playlist[i] accesses each track title using the current value of i.

    #  The f before a string literal in Python denotes an f-string, which is similar to template literals in JavaScript.
    #
# RESULT:
# My Spotify Playlist:
#1. Shape of You
# 2. Despacito
# 3. Uptown Funk
# 4. See You Again
# 5. Closer
#
```

- So, the loop iterates over each track in the playlist, printing the track number along with its title. The track numbers start from 1, hence the i+1 in the print statement.

<br>
<br>

### üëæ my question:

- is the `range()` used a lot or are there other ways to implement the spotify example, by other ways i mean in terms of "performance"

### chatgpt answer:

Depending on the specific requirements of your program, there are alternative methods you could consider for iterating over the playlist that might offer different trade-offs in terms of readability, performance, or simplicity.

<br>

Using `enumerate()`: Instead of using `range(len(playlist))`, you can use the **enumerate()** function, which returns both the index and the element from the iterable:

```python
playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
#
#
for i, track in enumerate(playlist, start=1):
    print(f"{i}. {track}")

```

<br>

- This approach is more Pythonic and often preferred because it's concise and clear.

<br>

Using a `for` loop directly on the list: In Python, you can loop directly over the elements of a list without explicitly using indices. This is simpler and often more readable:

```python
playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
#
#
for track in playlist:
    #
    #
    print(track)

```

- If you don't need the track numbers, this method is preferable as it's more straightforward.

<br>

## transform or filter

#### Using a list comprehension:

- If you need to transform or filter the elements of the playlist, you might consider using a list comprehension:

```python

# ------ **
print('---- example range 4 ----')
#------- **
#
playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
tracks_with_numbers = [f"{i+1}. {track}" for i, track in enumerate(playlist)]
for track_with_number in tracks_with_numbers:
    print(track_with_number)
# RESULT:
# My Spotify Playlist:
#1. Shape of You
# 2. Despacito
# 3. Uptown Funk
# 4. See You Again
# 5. Close
#
#
  #  The f before a string literal in Python denotes an f-string, which is similar to template literals in JavaScript.
```

- This approach can be more efficient if you're processing the entire playlist in one go, as list comprehensions are often faster than equivalent for loops.

<br>

### üü† In terms of performance, the differences between these methods are usually negligible unless you're working with very large datasets. Readability and maintainability should generally be prioritized over micro-optimizations unless performance is a critical concern.

<br>
<br>

## [Basic loop examples](https://youtu.be/23vCap6iYSs?feature=shared&t=36)

```python
names = ['dace', 'sarah', 'john']
for x in names:
    print(x)
    #result
```

<br>
<br>

```python
for x in 'Mississippi':
    print(x)
# RESULT

# M
# i
# s
# s
# i
# s
# s
# i
# p
# p
# i

# ------ **
print('---- example 7 ----')
#------- **
#
# LOOP over the list and check if there is a specific name

names2 = ['romeo', 'chiara', 'charles']

for xx in names2:
    if xx == 'romeo':
      break
print(xx)
# result: romeo


√§üñêÔ∏è
# ------ ** CORRECTED
print('---- example 8 ----')
#------- **
#
# LOOP over the list and check if there is a specific name

thenames = ["Dave", "Sara", "John"]

for px in thenames:
# you will notice that it will jump and continue the loop after sara
    if px == 'Sara':
      continue
    print(px)
    #üî¥ the problem why i couldnt get the 2 values as a result and only one, its because of the identation, read the MD about it
# result: Dave, John
#
#
```

<br>
<br>

## RANGE ( we already saw range( examples more at the top, but i want to continue with other exercises))

```python

# ------ **
print('---- example 9 RANGE (again) ----')
#------- **
#
## Do something similar with the RANGE

for example9 in range(2, 4):
    print(example9)

# result
# 2
# 3
#
# ------------
# ------ **
print('---- example 10 RANGE (again) ----')
#------- **
#
#
# :üñêÔ∏è
# Sample Spotify playlist data
#
#In this scenario, the for loop iterates over a range of indices (1, 2, 3), and for each index, it retrieves the corresponding song from the Spotify playlist data. You can then perform any analysis or processing on these songs within the loop.

spotify_playlist = [
    {"title": "Song 1", "artist": "Artist 1", "genre": "Pop", "popularity": 85},
    {"title": "Song 2", "artist": "Artist 2", "genre": "Rock", "popularity": 70},
    {"title": "Song 3", "artist": "Artist 3", "genre": "Hip-hop", "popularity": 90},
    {"title": "Song 4", "artist": "Artist 4", "genre": "Electronic", "popularity": 80},
    {"title": "Song 5", "artist": "Artist 5", "genre": "Pop", "popularity": 75}
]

# Analyzing a range of songs in the playlist
for index in range(1, 4):  # Analyze songs from index 1 to 3 (excluding 4)
    song = spotify_playlist[index]
    print("Analyzing song:", song["title"])
    # Add your analysis code here

#üñêÔ∏è result

# Analyzing song: Song 2
# Analyzing song: Song 3
# Analyzing song: Song 4
```

<br>
<br>

## üü° "iterating over a range with a specified step size"

#### explanation of the following

- üåà`range(0, 100, 5)` creates a sequence of numbers starting from 0 (inclusive), up to but not including 100 (exclusive), with a step size of 5. So, it generates numbers like 0, 5, 10, 15, ..., up to 95.

The for loop iterates over each number generated by range(0, 100, 5). In each iteration:

x takes on the current value from the range, starting from 0 and increasing by 5 in each step.
The print(x) statement prints the current value of x.
The loop continues until it reaches a value that is equal to or greater than 100, but since the stop value in the range() function is exclusive, it stops before reaching 100.

```python
# ------ **
print('---- example 11 RANGE   ----')
#------- **
# IN the following example
# we will start at 0, the second value means that we will go until 100 but since the condition states 100 we will go until 95, and the third value will determine how we want to reach the 100, in this case it will be 5 by 5

for x in range(0, 100, 5):
    print(x)
    #result:
#0
# 5
# 10
# 15
# 20
# 25
# 30
# 35
# 40
# 45
# 50
# 55
# 60
# 65
# 70
# 75
# 80
# 85
# 90
# 95
#
```

### A real scenario

```python
# Assuming you have a list of songs and their durations in seconds
songs = [("Song 1", 180),  # Song name and duration in seconds
         ("Song 2", 240),
         ("Song 3", 200)]

# Iterate over each song
for song_name, duration in songs:
    print(f"Song: {song_name}")
    print("Timestamps:")
    # Generate timestamps at 5-second intervals for the duration of the song
    for timestamp in range(0, duration, 5):
        print(f"{timestamp} seconds")
    print()
#
# result
#
Song: Song 1
Timestamps:
0 seconds
5 seconds
10 seconds
15 seconds
20 seconds
25 seconds
30 seconds
35 seconds
40 seconds
45 seconds
50 seconds
55 seconds
60 seconds
65 seconds
70 seconds
75 seconds
80 seconds
85 seconds
90 seconds
95 seconds
100 seconds
105 seconds
110 seconds
115 seconds
120 seconds
125 seconds
130 seconds
135 seconds
140 seconds
145 seconds
150 seconds
155 seconds
160 seconds
165 seconds
170 seconds
175 seconds

Song: Song 2
Timestamps:
0 seconds
5 seconds
10 seconds
15 seconds
20 seconds
25 seconds
30 seconds
35 seconds
40 seconds
45 seconds
50 seconds
55 seconds
60 seconds
65 seconds
70 seconds
75 seconds
80 seconds
85 seconds
90 seconds
95 seconds
100 seconds
105 seconds
110 seconds
115 seconds
120 seconds
125 seconds
130 seconds
135 seconds
140 seconds
145 seconds
150 seconds
155 seconds
160 seconds
165 seconds
170 seconds
175 seconds
180 seconds
185 seconds
190 seconds
195 seconds
200 seconds
205 seconds
210 seconds
215 seconds
220 seconds
225 seconds
230 seconds
235 seconds

Song: Song 3
Timestamps:
0 seconds
5 seconds
10 seconds
15 seconds
20 seconds
25 seconds
30 seconds
35 seconds
40 seconds
45 seconds
50 seconds
55 seconds
60 seconds
65 seconds
70 seconds
75 seconds
80 seconds
85 seconds
90 seconds
95 seconds
100 seconds
105 seconds
110 seconds
115 seconds
120 seconds
125 seconds
130 seconds
135 seconds
140 seconds
145 seconds
150 seconds
155 seconds
160 seconds
165 seconds
170 seconds
175 seconds
180 seconds
185 seconds
190 seconds
195 seconds
```

<br>

- üî¥This code will generate timestamps at 5-second intervals for each song and print them out. It's a simple example, but it demonstrates how you can use range() with a step size of 5 to iterate over time intervals in a song's duration.

<br>
<br>

### üëæ But why do i need timestamps? maybe adding an ad at certain time stamp?

### chatgpt answer:

- üåàExactly! Timestamps can be useful for various purposes, such as:

<br>

**Ad Placement:** As you suggested, you could use timestamps to determine when to insert advertisements or promotional content between songs. For example, you might decide to play an ad every 30 seconds or every minute during a user's listening session.

<br>

- **User Experience Enhancements:** Timestamps can also be used to enhance the user experience by allowing users to skip to specific parts of a song. You could provide a feature that lets users jump to specific timestamps within a song.

<br>

- üî¥**Analytics and Insights:** Timestamp data can provide valuable insights into user behavior and preferences. By analyzing when users skip or repeat certain parts of a song, you can gain insights into which parts of a song are most engaging or which parts may need improvement.

<br>

**Content Recommendations:** Timestamps can inform content recommendations. For example, if many users tend to skip a particular part of a song, you might avoid recommending similar songs with similar segments.

#### So, incorporating timestamps into your application opens up various possibilities for enhancing user engagement, optimizing content delivery, and providing personalized experiences.

<br>

## üü° Below is an example Python code snippet demonstrating how you could simulate tracking timestamps and analyzing user engagement for a YouTube-like application:

```python

```
