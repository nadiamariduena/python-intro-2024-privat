## üü® [Loops](https://youtu.be/23vCap6iYSs?feature=shared&t=36)

- while loops

- for loops

- else statement on the for loops

<br>
<br>

---

 <br>

### You will see this more at the bottom

https://www.stechies.com/string-formatting-f-stringin-python/

```python
  # üëæ The f before a string literal in Python denotes an f-string, which is similar to template literals in JavaScript.
      print(f"{i+1}. {playlist[i]}")
#
#
# another example
name = "Alice"
age = 30
print(f"My name is {name} and I am {age} years old.")

```

<br>
<br>

### WHILE loop

- Just like in javascript

- careful with the never ending loop that will crash your browser, so dont **print** the below

```python
value = 1
while value < 10:
    print(value) # :stop_sign: DONT!!!

    #result
    # infinite loop
```

<br>
<br>

### Do this:

- add the `+= 1` its going to increment everytime it goes through the LOOP, until it reaches the 9 (as we are incrementing 1), which is the end point `< 10`

```python
value = 1
while value < 10:
    print(value)
    value += 1
#result
1
2
3
4
5
6
7
8
9
#It doesnt reach the 10, because the condition tells that "WHILE" its less than 10. if you want to show the 10, you can change the condition from < 10 to <= 10 (less or equal to 10)
value = 1
while value <= 10:
    print(value)
    value += 1
#result
1
2
3
4
5
6
7
8
9
10
```

### Another WAY to break the LOOP

```python
value = 1
while value <= 10:
    print(value)
    if value == 5:
        break #if the condition is met, it will stop the loop at 5
    value += 1
```

<br>
<br>

# ELSE

### üñêÔ∏è USING the else

- You can use it once the loop is completed and the condition is no longer TRUE

```python
while value <= 10:
  value += 1
  if value == 5:
     continue  # If value is 5, the loop skips the remaining code in this iteration and continues to the next iteration
  print(value)
  #
  # ELSE: You can use it once the loop is completed and the condition is no longer TRUE
  #
else:
    print("Value is now equal to " + value) #üßß You will get an error if you try to print this, so convert the TYPE

```

## üî¥ the error

```python
    print("Value is now equal to " +  value)
          ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~
TypeError: can only concatenate str (not "int") to str
```

<br>

### üåà convert the TYPE to str (string)

```python
else:
    print("Value is now equal to " + str(value))
```

<br>
<br>

---

<br>
<br>

## üü° FOR loop (sequence)

<br>

#### chatgpt basict doc about the topic:

<br>

- In Python, a for **loop is used to iterate over a sequence (such as a list, tuple, string, or range) or any other iterable object.**

> The basic syntax of a for loop in Python is:

```python

for item in sequence:
    # do something with item

```

#### The `for` keyword indicates the start of the loop.

- **item** is a variable that will take on the value of each element in the sequence during each iteration of the loop.

**sequence** is the collection of items over which the loop will iterate.

```python

fruits = ["apple", "banana", "cherry"]
#
# fruit will represent the content within the fruits list/ array(js)
for fruit in fruits:
    print(fruit)

```

<br>

### In this example, the for loop iterates over the fruits list.

‚úã **During each iteration**, the variable fruit takes on the value of each element in the list ("apple", "banana", and "cherry" in sequence), and it prints each fruit.

You can also use the `range()` function to generate a sequence of numbers:

<br>

```python
for i in range(5):
    print(i)

    # The for loop continues iterating until it has gone through all the elements in the sequence or until a break statement is encountered, which exits the loop prematurely.

# result
# 0
# 1
# 2
# 3
# 4
```

#### The for loop continues iterating until it has gone through all the elements in the sequence or until a break statement is encountered, which exits the loop prematurely.

<br>
<br>

### How can I use the `range()` for a real scenario?

<br>

- Let's imagine you're building a program that simulates a **Spotify** playlist, and you want to display the track numbers along with their titles.

- You can use the `range()` function to generate track numbers dynamically, especially if your playlist can have a variable number of tracks.

<br>

```python
playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
for i in range(len(playlist)):
    print(f"{i+1}. {playlist[i]}")

```

<br>
<br>

```python
#
#

playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
##
# len(playlist) returns the length of the playlist, which is the number of tracks.
#
# i iterates over each number generated by range(), representing the track number.

#
for i in range(len(playlist)):
    #
    #range(len(playlist)) generates a sequence of numbers from 0 to len(playlist) - 1. This sequence corresponds to the indices of the tracks in the playlist.
    #
    print(f"{i+1}. {playlist[i]}")
    #  playlist[i] accesses each track title using the current value of i.

    #  The f before a string literal in Python denotes an f-string, which is similar to template literals in JavaScript.
    #
# RESULT:
# My Spotify Playlist:
#1. Shape of You
# 2. Despacito
# 3. Uptown Funk
# 4. See You Again
# 5. Closer
#
```

- So, the loop iterates over each track in the playlist, printing the track number along with its title. The track numbers start from 1, hence the i+1 in the print statement.

<br>
<br>

### üëæ my question:

- is the `range()` used a lot or are there other ways to implement the spotify example, by other ways i mean in terms of "performance"

### chatgpt answer:

Depending on the specific requirements of your program, there are alternative methods you could consider for iterating over the playlist that might offer different trade-offs in terms of readability, performance, or simplicity.

<br>

Using `enumerate()`: Instead of using `range(len(playlist))`, you can use the **enumerate()** function, which returns both the index and the element from the iterable:

```python
playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
#
#
for i, track in enumerate(playlist, start=1):
    print(f"{i}. {track}")

```

<br>

- This approach is more Pythonic and often preferred because it's concise and clear.

<br>

Using a `for` loop directly on the list: In Python, you can loop directly over the elements of a list without explicitly using indices. This is simpler and often more readable:

```python
playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
#
#
for track in playlist:
    #
    #
    print(track)

```

- If you don't need the track numbers, this method is preferable as it's more straightforward.

<br>

## transform or filter

#### Using a list comprehension:

- If you need to transform or filter the elements of the playlist, you might consider using a list comprehension:

```python

# ------ **
print('---- example range 4 ----')
#------- **
#
playlist = ["Shape of You", "Despacito", "Uptown Funk", "See You Again", "Closer"]

print("My Spotify Playlist:")
tracks_with_numbers = [f"{i+1}. {track}" for i, track in enumerate(playlist)]
for track_with_number in tracks_with_numbers:
    print(track_with_number)
# RESULT:
# My Spotify Playlist:
#1. Shape of You
# 2. Despacito
# 3. Uptown Funk
# 4. See You Again
# 5. Close
#
#
  #  The f before a string literal in Python denotes an f-string, which is similar to template literals in JavaScript.
```

- This approach can be more efficient if you're processing the entire playlist in one go, as list comprehensions are often faster than equivalent for loops.

<br>

### üü† In terms of performance, the differences between these methods are usually negligible unless you're working with very large datasets. Readability and maintainability should generally be prioritized over micro-optimizations unless performance is a critical concern.

<br>
<br>

## [Basic loop examples](https://youtu.be/23vCap6iYSs?feature=shared&t=36)

```python
names = ['dace', 'sarah', 'john']
for x in names:
    print(x)
    #result
```

<br>
<br>

```python
for x in 'Mississippi':
    print(x)
# RESULT

# M
# i
# s
# s
# i
# s
# s
# i
# p
# p
# i

# ------ **
print('---- example 7 ----')
#------- **
#
# LOOP over the list and check if there is a specific name

names2 = ['romeo', 'chiara', 'charles']

for xx in names2:
    if xx == 'romeo':
      break
print(xx)
# result: romeo


√§üñêÔ∏è
# ------ ** CORRECTED
print('---- example 8 ----')
#------- **
#
# LOOP over the list and check if there is a specific name

thenames = ["Dave", "Sara", "John"]

for px in thenames:
# you will notice that it will jump and continue the loop after sara
    if px == 'Sara':
      continue
    print(px)
    #üî¥ the problem why i couldnt get the 2 values as a result and only one, its because of the identation, read the MD about it
# result: Dave, John
#
#
```

<br>
<br>

## RANGE ( we already saw range( examples more at the top, but i want to continue with other exercises))

```python

# ------ **
print('---- example 9 RANGE (again) ----')
#------- **
#
## Do something similar with the RANGE

for example9 in range(2, 4):
    print(example9)

# result
# 2
# 3
#
# ------------
# ------ **
print('---- example 10 RANGE (again) ----')
#------- **
#
#
# :üñêÔ∏è
# Sample Spotify playlist data
#
#In this scenario, the for loop iterates over a range of indices (1, 2, 3), and for each index, it retrieves the corresponding song from the Spotify playlist data. You can then perform any analysis or processing on these songs within the loop.

spotify_playlist = [
    {"title": "Song 1", "artist": "Artist 1", "genre": "Pop", "popularity": 85},
    {"title": "Song 2", "artist": "Artist 2", "genre": "Rock", "popularity": 70},
    {"title": "Song 3", "artist": "Artist 3", "genre": "Hip-hop", "popularity": 90},
    {"title": "Song 4", "artist": "Artist 4", "genre": "Electronic", "popularity": 80},
    {"title": "Song 5", "artist": "Artist 5", "genre": "Pop", "popularity": 75}
]

# Analyzing a range of songs in the playlist
for index in range(1, 4):  # Analyze songs from index 1 to 3 (excluding 4)
    song = spotify_playlist[index]
    print("Analyzing song:", song["title"])
    # Add your analysis code here

#üñêÔ∏è result

# Analyzing song: Song 2
# Analyzing song: Song 3
# Analyzing song: Song 4
```

<br>
<br>

## üü° "iterating over a range with a specified step size"

#### explanation of the following

- üåà`range(0, 100, 5)` creates a sequence of numbers starting from 0 (inclusive), up to but not including 100 (exclusive), with a step size of 5. So, it generates numbers like 0, 5, 10, 15, ..., up to 95.

The for loop iterates over each number generated by range(0, 100, 5). In each iteration:

x takes on the current value from the range, starting from 0 and increasing by 5 in each step.
The print(x) statement prints the current value of x.
The loop continues until it reaches a value that is equal to or greater than 100, but since the stop value in the range() function is exclusive, it stops before reaching 100.

```python
# ------ **
print('---- example 11 RANGE   ----')
#------- **
# IN the following example
# we will start at 0, the second value means that we will go until 100 but since the condition states 100 we will go until 95, and the third value will determine how we want to reach the 100, in this case it will be 5 by 5

for x in range(0, 100, 5):
    print(x)
    #result:
#0
# 5
# 10
# 15
# 20
# 25
# 30
# 35
# 40
# 45
# 50
# 55
# 60
# 65
# 70
# 75
# 80
# 85
# 90
# 95
#
```

### A real scenario

```python
# Assuming you have a list of songs and their durations in seconds
songs = [("Song 1", 180),  # Song name and duration in seconds
         ("Song 2", 240),
         ("Song 3", 200)]

# Iterate over each song
for song_name, duration in songs:
    print(f"Song: {song_name}")
    print("Timestamps:")
    # Generate timestamps at 5-second intervals for the duration of the song
    for timestamp in range(0, duration, 5):
        print(f"{timestamp} seconds")
    print()
#
# result
#
Song: Song 1
Timestamps:
0 seconds
5 seconds
10 seconds
15 seconds
20 seconds
25 seconds
30 seconds
35 seconds
40 seconds
45 seconds
50 seconds
55 seconds
60 seconds
65 seconds
70 seconds
75 seconds
80 seconds
85 seconds
90 seconds
95 seconds
100 seconds
105 seconds
110 seconds
115 seconds
120 seconds
125 seconds
130 seconds
135 seconds
140 seconds
145 seconds
150 seconds
155 seconds
160 seconds
165 seconds
170 seconds
175 seconds

Song: Song 2
Timestamps:
0 seconds
5 seconds
10 seconds
15 seconds
20 seconds
25 seconds
30 seconds
35 seconds
40 seconds
45 seconds
50 seconds
55 seconds
60 seconds
65 seconds
70 seconds
75 seconds
80 seconds
85 seconds
90 seconds
95 seconds
100 seconds
105 seconds
110 seconds
115 seconds
120 seconds
125 seconds
130 seconds
135 seconds
140 seconds
145 seconds
150 seconds
155 seconds
160 seconds
165 seconds
170 seconds
175 seconds
180 seconds
185 seconds
190 seconds
195 seconds
200 seconds
205 seconds
210 seconds
215 seconds
220 seconds
225 seconds
230 seconds
235 seconds

Song: Song 3
Timestamps:
0 seconds
5 seconds
10 seconds
15 seconds
20 seconds
25 seconds
30 seconds
35 seconds
40 seconds
45 seconds
50 seconds
55 seconds
60 seconds
65 seconds
70 seconds
75 seconds
80 seconds
85 seconds
90 seconds
95 seconds
100 seconds
105 seconds
110 seconds
115 seconds
120 seconds
125 seconds
130 seconds
135 seconds
140 seconds
145 seconds
150 seconds
155 seconds
160 seconds
165 seconds
170 seconds
175 seconds
180 seconds
185 seconds
190 seconds
195 seconds
```

<br>

- üî¥This code will generate timestamps at 5-second intervals for each song and print them out. It's a simple example, but it demonstrates how you can use range() with a step size of 5 to iterate over time intervals in a song's duration.

<br>
<br>

### üëæ But why do i need timestamps? maybe adding an ad at certain time stamp?

### chatgpt answer:

- üåàExactly! Timestamps can be useful for various purposes, such as:

<br>

**Ad Placement:** As you suggested, you could use timestamps to determine when to insert advertisements or promotional content between songs. For example, you might decide to play an ad every 30 seconds or every minute during a user's listening session.

<br>

- **User Experience Enhancements:** Timestamps can also be used to enhance the user experience by allowing users to skip to specific parts of a song. You could provide a feature that lets users jump to specific timestamps within a song.

<br>

---

<br>

### üî¥Analytics and Insights:

- Timestamp data can provide valuable insights into user behavior and preferences. By analyzing when users skip or repeat certain parts of a song, you can gain insights into which parts of a song are most engaging or which parts may need improvement.

<br>

**In a YouTube app**, timestamp data can indeed be valuable for analytics and insights into user behavior. Here's a real scenario where timestamp data can be used for analysis:

##### ‚úã Scenario: Analyzing Video Engagement

Suppose you have a YouTube app that allows users to watch various types of videos, including educational tutorials. You want to understand how users engage with these tutorials to improve content quality and user experience.

<br>

**Timestamp Tracking:** You track timestamps whenever users pause, rewind, or fast forward the video. This data provides insight into which parts of the video users find engaging, confusing, or uninteresting.

**Engagement Metrics:** By analyzing the timestamps, you can calculate engagement metrics such as:

**Watch Time:** Total time spent watching the video.
Average Watch Time: Average duration users watch before pausing or skipping.
Retention Rate: Percentage of users who watch the entire video versus those who drop off at certain timestamps.
Content Improvement: Timestamp data helps identify specific segments of the video that may need improvement. For example:

**High Engagement:** Parts where users frequently pause or rewind may indicate complex or interesting content that users want to review.
Low Engagement: Parts where users consistently fast forward or drop off may indicate sections that are too lengthy, repetitive, or uninteresting.

**Personalized Recommendations:** Timestamp analysis can inform personalized recommendations.

#### For instance:

If many users rewatch a particular segment, you could recommend similar videos or topics.

If users consistently skip certain sections, you could adjust recommendations or suggest alternative content.

**A/B Testing:** You can use timestamp data to conduct A/B tests by making changes to specific parts of the video and measuring the impact on user engagement at those timestamps.

Overall, timestamp analysis in a YouTube app provides valuable insights into user preferences, content effectiveness, and opportunities for improvement, leading to a more engaging and personalized user experience.

#### Overall, timestamp analysis in a YouTube app provides valuable insights into user preferences, content effectiveness, and opportunities for improvement, leading to a more engaging and personalized user experience.

## üëæ SHOW me real scenario on a youtube app , where the timestamp is used for tracking

### ‚úã chatgpt

Let's create a simplified scenario where we track user actions **(pausing, rewinding, fast forwarding)** during video playback in a YouTube-like application. We'll use Python to simulate this tracking:

```python
# Define a list of timestamps representing user actions during video playback
user_actions = [
    {"action": "play", "timestamp": 0},
    {"action": "pause", "timestamp": 10},
    {"action": "play", "timestamp": 15},
    {"action": "rewind", "timestamp": 25},
    {"action": "play", "timestamp": 20},
    {"action": "fast_forward", "timestamp": 35},
    {"action": "pause", "timestamp": 50},
    {"action": "play", "timestamp": 55}
]

# Initialize variables to track timestamps for different actions
pauses = []
rewinds = []
fast_forwards = []

# Iterate over user_actions and track timestamps for different actions
for action in user_actions:
    if action["action"] == "pause":
        pauses.append(action["timestamp"])
    elif action["action"] == "rewind":
        rewinds.append(action["timestamp"])
    elif action["action"] == "fast_forward":
        fast_forwards.append(action["timestamp"])

# Print timestamps for different actions
print("Pauses:", pauses)
print("Rewinds:", rewinds)
print("Fast Forwards:", fast_forwards)

```

<br>

### i am a bit confused about the values 25 an 20, why arent these 2 in order

```python
  {"action": "rewind", "timestamp": 25},
    {"action": "play", "timestamp": 20},
```

in a chronological sense, **it appears** that the "play" action with a timestamp of 20 occurs before the "rewind" action with a timestamp of 25. This might seem confusing at first glance.

**However**, it's essential to understand that the **timestamps** in this context **represent moments within the video playback, not necessarily\*** the absolute chronological order of user actions.

#### in this example:

- The timestamp for the "rewind" action (25 seconds) indicates that the user decided to rewind the video playback to a previous point at 25 seconds.

- The timestamp for the "play" action (20 seconds) indicates that the user then resumed playback from that rewound position at 20 seconds.

So, even though the timestamp for the "rewind" action is higher (25) than the timestamp for the "play" action (20), it indicates the point in the video where the user rewound to, not the order in which the actions occurred in real-time.

This discrepancy in timestamps might occur due to various factors, such as the user's interaction with the interface or the way timestamps are recorded and processed in the application.

<br>

---

<br>

**Content Recommendations:** Timestamps can inform content recommendations. For example, if many users tend to skip a particular part of a song, you might avoid recommending similar songs with similar segments.

#### So, incorporating timestamps into your application opens up various possibilities for enhancing user engagement, optimizing content delivery, and providing personalized experiences.

<br>

## üü° Below is an example Python code snippet demonstrating how you could simulate tracking timestamps and analyzing user engagement for a YouTube-like application:

```python
# Sample timestamps representing user actions (in seconds)
timestamps = [10, 25, 45, 60, 70, 90, 110, 120, 140]

# Calculate engagement metrics
total_watch_time = timestamps[-1]  # Last timestamp represents total watch time
average_watch_time = total_watch_time / len(timestamps)
retention_rate = (len(timestamps) / total_watch_time) * 100  # Percentage of total watch time covered by timestamps

# Analyze engagement by segmenting timestamps
segments = []
#
#
current_segment_start = 0
# for timestamp in timestamps:
#     segment_duration = timestamp - current_segment_start
#     segments.append((current_segment_start, segment_duration))
#     current_segment_start = timestamp

for timestamp in timestamps:
    # Calculate the duration of the current segment by subtracting the start time of the current segment
    # from the timestamp of the next segment
    segment_duration = timestamp - current_segment_start

    # Append a tuple containing the start time of the current segment and its duration to the list of segments
    segments.append((current_segment_start, segment_duration))

    # Update the start time of the next segment to be the current timestamp for the next iteration
    current_segment_start = timestamp



# Display results
print("Engagement Metrics:")
print(f"Total Watch Time: {total_watch_time} seconds")
print(f"Average Watch Time: {average_watch_time} seconds")
# Print the retention rate with 2 decimal places and a percentage sign
print(f"Retention Rate: {retention_rate:.2f}%")

# Print a new line followed by a heading for segment analysis
print("\nSegment Analysis:")

# Iterate over the segments list using enumerate to get both the index and the segment tuple
for i, (start, duration) in enumerate(segments, 1):
    # Print the segment number (index + 1), start time, and duration of each segment
    print(f"Segment {i}: Start Time = {start} seconds, Duration = {duration} seconds")

```

- We print the retention rate with two decimal places and a percentage sign.

- We print a new line and a heading for segment analysis.

- We use a for loop to go through each segment in the list, and we use **enumerate()** to get both the index and the segment tuple.

#### For each segment, we print its number, start time, and duration in seconds.

<br>
<br>

---

<br>
<br>

## Else statement on a for loop

```python
for xmore in range(5, 101, 5)
print(xmore)
else:
    print('Glad that\'s over!')
```

<br>
<br>

## üü° NESTED LOOPS 1)

<br>

```python
# ------ **
print('---- example 15  NESTED loops----')
#------- **

#looping through 2 different lists

names2 = ['Daria', 'Esze', 'Somal']
actions = ['codes',  'eats', 'sleeps']

#
#for each name we are going to do something
for name in names2:
    for action in actions:
        print(name + ' ' + action + '.')
#result
# Daria codes.
# Daria eats.
# Daria sleeps.
# Esze codes.
# Esze eats.
# Esze sleeps.
# Somal codes.
# Somal eats.
# Somal sleeps.
```

## üü° NESTED LOOPS 2)

```python

# --------- **
print('------ nested loop 2')
## Now get the opposite
#
names3 = ['Daria', 'Esze', 'Somal']
actions3 = ['codes',  'eats', 'sleeps']
#
#
for action3 in actions3:
    for name3 in names3:
        print(name3 + ' ' + action3 + '.')
# result:
#üñêÔ∏è notice the difference, here we inserted the name inside the loop 1, compare the result with the result of the 1 nested loop
#
#Daria codes.
# Esze codes.
# Somal codes.
# Daria eats.
# Esze eats.
# Somal eats.
# Daria sleeps.
# Esze sleeps.
# Somal sleeps.
#üñêÔ∏è its also possible to add more for loops within, but check first how this can affect the performance
```

## üü° NESTED LOOPS 3)

<br>
<br>

#### with only 4 loop

```python
## more loops, in this one i will have 4 lists to include in 4 loops

names4 = ["Alice", "Bob", "Charlie"]
activities = ["running", "swimming", "cycling"]
foods = ["pizza", "sushi", "burgers"]
cities = ["New York", "Los Angeles", "Chicago"]

for name4 in names4:
        print(f"{name4} likes {activities}, enjoys eating {foods}, and lives in {cities}")
#
##
# OUTPUT
Alice likes ['running', 'swimming', 'cycling'], enjoys eating ['pizza', 'sushi', 'burgers'], and lives in ['New York', 'Los Angeles', 'Chicago']
Bob likes ['running', 'swimming', 'cycling'], enjoys eating ['pizza', 'sushi', 'burgers'], and lives in ['New York', 'Los Angeles', 'Chicago']
Charlie likes ['running', 'swimming', 'cycling'], enjoys eating ['pizza', 'sushi', 'burgers'], and lives in ['New York', 'Los Angeles', 'Chicago']
```
